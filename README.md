# CS-300-Analysis-and-Design


#    What was the problem you were solving in the projects for this course?
Throughout both projects in CS-300, I was assessing the problem of finding a fast data structure for a college course database, which can be updated in real time, searched within, loaded from a CSV file, and handle course deletions.

#    How did you approach the problem? Consider why data structures are important to understand.
This problem required good performance and flexibility within the algorithm. I compared three data structures - Binary search trees, traditional linear vectors, and hash table lookups. I found that they were suited best for different purposes, and offered differing levels of performance. With O-type notation, I was able to determine that the binary search tree would have the best performance for the size of my data - The finite, comparitively small (liable to finish between a length of 20-50) list of courses, each of which had two 1:1 metadata entries composed of the course ID and the title, as well as a finite 0..* metadata array of prerequisite courses. I also needed to allow the user to print a sorted version of the courses, but the mechanisms behind the BST automatically result in a form of sorting by constructing branches in accordings to greater than and less than relationships, which solves this requirement handily. 

Aside from addressing my programming problem I recognized that each data structure has its own use cases. Vectors/arrays are simple and easy to implement, and are useful for fixed-size, smaller scale data sets, such as the prerequisite courses attached to each course object. Hash tables are a data type with generally consistent time complexity for searching, insertion, and deletion, and are able to handle insertions and deletions with grace, but run the risk of slowdown if the hash function used causes collisions. Avoiding collisions means a more complex hash algorithm, which means more slowdown when inserting, and hash tables also do not have a sorting implementation occur naturally within their design. Consequently, neither of these data types were quite right for my needs within these projects, but could serve well for other projects with other requirements. 

#    How did you overcome any roadblocks you encountered while going through the activities or project?
I don't recall having very many roadblocks throughout my work. Whenever I was confused about the construction of a data type, I'd refer to the resources, typically the Zybooks but on occasion a document on the internet in relation to the purpose and structure of an algorithm, and program my structure writing the methodology and purposes out as comments in English alongside my declarations and my functions. There was a specific instance where one of the assignments had a vast array of errors related to the standard C++ libraries which I resolved after a very confusing ten or fifteen minutes by starting from the very beginning of the document, which is when I realized there was a missing "/" in the front of a comment, which was causing the first import to not function, causing all of my issues. This was a very good lesson in due diligence and looking for the simple solution first.

#    How has your work on this project expanded your approach to designing software and developing programs?
I think this may have been one of the most meaningful projects I've enjoyed so far throughout my college career. It was a fantastic exercise in practical application of pseudocode, understanding the client's requirements, determining the best route to fulfill them, and creating a practical application from scratch. As someone who has regarded pseudocode as generally a waste of time, this exercise has genuinely expanded my appreciation of doing things right and planning things properly. I also learned about neat data structure algorithms, which gets the imagination active and the optimizer mindset excited.

#    How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
I've always made a good effort to write well-formatted, clean code with descriptive comments. Readability, maintainability, and adaptability are all important. Something I definitely picked up from this project as a natural progression of experience and developmental skill is being wiser about encapsulation and delegation of properties and functions to specific structs and data types. I've improved at writing and planning objects. 
